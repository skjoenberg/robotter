ERSP Player Driver Source Package
=================================

Jonas Fonseca <fonseca@diku.dk> and Bue Petersen <buep@diku.dk>
Department of Computer Science, University of Copenhagen
January 2007

In this software package you will find source code for the developed
driver, examples configurations for both Player and Player/Stage and
some test programs using one or several of the features provided by
the drivers.

Getting started
---------------
The quick 3-step guide to getting started is:

 1. Build the drivers and test programs by running:

	$ make

 2. Start the player server. If you are going to work on the
    real-world Scorpion robot use:

	$ make player/scorpion.cfg

    If you want to run a test program in a simulation start
    Stage using:
 
	$ make stage/cave/cave.cfg

 3. Start a test program. A good and simple example is the random walk
    test program that uses the IR range sensors to navigate. Start it
    by running:

	$ ./randomwalk

The directory structure
-----------------------
The package contains the following directories and files:

 - driver: Driver source code. Contains the ERSP Player driver as well
   as other drivers specifically for the environment used at DIKU.

 - player: Player configuration files for running player using the
   physical robot.

 - stage: Player/Stage configuration files and worlds for running
   simulations.

 - test: Sample programs for experiments and tests.
 
 - ersp-test: Sample programs for experiments and tests using ERSP.

 - Makefile: A simple Makefile for building the drivers and test
   programs, and running the player with the correct environments. More
   info on using the Makefile is given in the Makefile usage section
   below.

Build dependencies
------------------
To use this source package, the following programs and libraries are
required:

 - The pkg-config package management tool for locating where
   Player/Stage and ERSP are installed.

 - Player and Stage version 2.0.0 or later.

 - Autotools (aclocal, autoheader, autoconf, automake and autoreconf)
   for bootstrapping the build system in the driver/ directory.

 - GCC and GNU Make.

Makefile usage
--------------
By default, running "make" in the top-level directory of the source
package will build all test programs and drivers. The Makefile also
defines a "clean" rule for removing compiled files, and a "distclean"
which also tries to remove driver specific build files.

An overview of test program and rules to build them can be requested
by running:

	$ make test-help

To only build test programs use:

	$ make test-all

To only build drivers use:

	$ make driver-all

Apart from rules to build the driver and test programs, the Makefile
also defines some rules for starting and stopping player. To list
help on this run:

	$ make stage-help

More information on running robot control programs and starting Player
is given below.

Running robot control programs
------------------------------
This section explains how to run a robot control program using
Player/Stage. In the following, it is assumed that the commands are
run from the source package's base directory (where this README file
resides).

First, setup the environment to tell Player where to locate driver
plugins provided by this source package. By default, the drivers are
installed (when running "make driver-all") in driver/lib, so this will
be used in the following example. When Player is asked to load a
driver plugin it looks in the directories specified using the
PLAYERPATH environment variable. Thus, use the following to tell
Player about the drivers in driver/lib:

	$ export PLAYERPATH="$(pwd)/driver/lib:$PLAYERPATH"

Note, this environment variable only needs to be set once. Also, if
you use "make" to start player all this is done for you.

Next, start player with one of the available configuration files.
Depending on whether the robot control program should run in a
simlation using Stage or on the physical robot, choose a .cfg file in
the stage/ or the player/ directories, respectively. See the README
files in each directory for what the various configuartion files of
do. Then start player by passing the configuration file as the
programs only argument:

	$ player <cfg-file>

or alternatively use "make" to start player with some extra
environment (read PLAYERPATH) defined and with the playerv (Player
Viewer) program:

	$ make <cfg-file>

Examples:

 - To start a simulation of a Scorpion robot in a seamlessly random
   world, try the cave world simulation:

	$ player stage/cave/cave.cfg
 
 - To run you program on the real-world robot use the configuration
   file for the Scorpion ERSP driver:

	$ player player/scorpion.cfg

Finally, run your robot control program, e.g. use one from the test/
directory:

	$ ./square

A note about Player/Stage configuration files
---------------------------------------------
For each Stage configuration files there is a Player configuration
file that provides the same interfaces. However, this is not
neccesarily the case the other way around, since Stage does not
support simulation of all the interfaces supported by Player.

Anyway, you should be able to assume that if your program works with
a Stage configuration file, it will also work with the Player
configuration file having the same name. For example, if you program
works with stage/cave/cave.cfg, it should also work with
player/cave.cfg.
